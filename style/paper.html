<!DOCTYPE html>
<!-- saved from url=(0033)https://shenjiasi.com/papers.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
<!-- Use mobile-aware viewport -->

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link rel="stylesheet" href="./Jiasi Shen _ HKUST CSE_files/sjs-theme.css">
<link rel="shortcut icon" type="image/x-icon" href="https://shenjiasi.com/favicon.ico">
<script src="./Jiasi Shen _ HKUST CSE_files/jquery.js"></script>
<script src="./Jiasi Shen _ HKUST CSE_files/bootstrap.js"></script>

<title> Shimin DI | HKUST CSE </title>
</head>
<body data-new-gr-c-s-check-loaded="14.1162.0" data-gr-ext-installed="">
  
<div class="clearfix px-4 pt-1 pb-0 mb-3 bg-dark topbar topbar-dark">
<div class="float-left">
  <h1 class="text-nowrap" style="display:inline">
    <a href="https://shenjiasi.com/index.html"> Shimin DI </a>
  </h1>

<!--
<a class="text-nowrap" id="i-pn" href="https://shenjiasi.com/pronounce.html">
<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" opacity=".1" fill="none"></path><path d="M12 1c-4.97 0-9 4.03-9 9v7c0 1.66 1.34 3 3 3h3v-8H5v-2c0-3.87 3.13-7 7-7s7 3.13 7 7v2h-4v8h3c1.66 0 3-1.34 3-3v-7c0-4.97-4.03-9-9-9z"></path></svg>
Pronunciation
</a>
-->
</div>
<div class="float-right">
  <ul class="nav">
    <li class="nav-item"> <a class="nav-link" href="./index.html">Home</a> </li>
    <li class="nav-item"> <a class="nav-link" href="./group.html">Group</a> </li>
    <li class="nav-item"> <a class="nav-link" href="./papers.html">Papers</a> </li>
  </ul>
</div>
</div>

    <div class="container-fluid px-4">
      <h3>Preprints</h3>
      
<span class="paper-list">
<ul><li class="paper-tight" id="p:tbdshear"><span class="author"><span class="me">Jiasi Shen</span>, Martin Rinard. </span><span class="date">TBD. </span><span class="papertitle">Active Loop Detection for Applications that Access Databases. </span><span class="booktitle">In submission. </span><span class="note"><a href="https://hdl.handle.net/1721.1/138144">https://hdl.handle.net/1721.1/138144</a>. </span></li>
<li class="paper-tight" id="p:tbdkq"><span class="author"><span class="me">Jiasi Shen</span>, Martin Rinard, Nikos Vasilakis. </span><span class="date">TBD. </span><span class="papertitle">Automatic Synthesis of Parallel Unix Commands and Pipelines with KumQuat. </span><span class="booktitle">In submission. </span><span class="note"><a href="https://arxiv.org/abs/2012.15443">arXiv:2012.15443</a>. </span></li></ul>
</span>

      <h3>Peer-Reviewed Publications</h3>
      
<span class="paper-list">
<ul><li class="paper-tight" id="p:ppopp22"><span class="author"><span class="me">Jiasi Shen</span>, Martin Rinard, Nikos Vasilakis. </span><span class="date">2022. </span><span class="papertitle">POSTER: Automatic Synthesis of Parallel Unix Commands and Pipelines with KumQuat. </span><span class="booktitle">27th ACM SIGPLAN Annual Symposium on Principles and Practice of Parallel Programming (<a class="venue" href="https://ppopp22.sigplan.org/">PPoPP</a>), poster. </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:ppopp22" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:ppopp22">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/ppopp22-kumquat.pdf">Paper (pdf)</a>
<a class="btn btn-link btn-sm" href="https://doi.org/10.1145/3503221.3508400">DOI</a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/ppopp22-kumquat-slides.pptx">Slides (pptx)</a></div>
<div class="abstract collapse" id="a:ppopp22"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">We present KumQuat, a system for automatically generating data-parallel implementations of Unix shell commands and pipelines. The generated parallel versions split input streams, execute multiple instantiations of the original pipeline commands to process the splits in parallel, then combine the resulting parallel outputs to produce the final output stream. KumQuat automatically synthesizes the combine operators, with a domain-specific combiner language acting as a strong regularizer that promotes efficient inference of correct combiners. We present experimental results that show that these combiners enable the effective parallelization of our benchmark scripts.</p><a class="card-link" href="https://shenjiasi.com/assets/ppopp22-kumquat.pdf">Paper (pdf)</a></div>
</div>
</li>
<li class="paper-tight" id="p:ccs21"><span class="author">Nikos Vasilakis, Achilles Benetopoulos, Shivam Handa, Alizee Schoen, <span class="me">Jiasi Shen</span>, Martin Rinard. </span><span class="date">2021. </span><span class="papertitle">Supply-Chain Vulnerability Elimination via Active Learning and Regeneration. </span><span class="booktitle">ACM SIGSAC Conference on Computer and Communications Security (<a class="venue" href="https://www.sigsac.org/ccs/CCS2021/">CCS</a>). </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:ccs21" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:ccs21">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/ccs21-harp.pdf">Paper (pdf)</a>
<a class="btn btn-link btn-sm" href="https://doi.org/10.1145/3460120.3484736">DOI</a></div>
<div class="abstract collapse" id="a:ccs21"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">Software supply-chain attacks target components that are integrated into client applications. Such attacks often target widely-used components, with the attack taking place via operations (for example, file system or network accesses) that do not affect those aspects of component behavior that the client observes. We propose new active library learning and regeneration (ALR) techniques for inferring and regenerating the client-observable behavior of software components. Using increasingly sophisticated rounds of exploration, ALR generates inputs, provides these inputs to the component, and observes the resulting outputs to infer a model of the component's behavior as a program in a domain-specific language. We present Harp, an ALR system for string processing components. We apply Harp to successfully infer and regenerate string-processing components written in JavaScript and C/C++. Our results indicate that, in the majority of cases, Harp completes the regeneration in less than a minute, remains fully compatible with the original library, and delivers performance indistinguishable from the original library. We also demonstrate that Harp can eliminate vulnerabilities associated with libraries targeted in several highly visible security incidents, specifically <code>event-stream</code>, <code>left-pad</code>, and <code>string-compare</code>.</p><a class="card-link" href="https://shenjiasi.com/assets/ccs21-harp.pdf">Paper (pdf)</a></div>
</div>
</li>
<li class="paper-tight" id="p:toplas21"><span class="author"><span class="me">Jiasi Shen</span>, Martin Rinard. </span><span class="date">2021. </span><span class="papertitle">Active Learning for Inference and Regeneration of Applications that Access Databases. </span><span class="booktitle">ACM Transactions on Programming Languages and Systems (<a class="venue" href="https://dl.acm.org/journal/toplas">TOPLAS</a>). </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:toplas21" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:toplas21">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/toplas21-konure.pdf">Paper (pdf)</a>
<a class="btn btn-link btn-sm" href="https://doi.org/10.1145/3430952">DOI</a></div>
<div class="abstract collapse" id="a:toplas21"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">We present <em>Konure</em>, a new system that uses active learning to infer models of applications that retrieve data from relational databases. Konure comprises a domain-specific language (each model is a program in this language) and associated inference algorithm that infers models of applications whose behavior can be expressed in this language. The inference algorithm generates inputs and database configurations, runs the application, then observes the resulting database traffic and outputs to progressively refine its current model hypothesis. Because the technique works with only externally observable inputs, outputs, and database configurations, it can infer the behavior of applications written in arbitrary languages using arbitrary coding styles (as long as the behavior of the application is expressible in the domain-specific language). Konure also implements a regenerator that produces a translated Python implementation of the application that systematically includes relevant security and error checks.</p><a class="card-link" href="https://shenjiasi.com/assets/toplas21-konure.pdf">Paper (pdf)</a></div>
</div>
</li>
<li class="paper-tight" id="p:msr20rr"><span class="author">Jürgen Cito<sup>1</sup>, <span class="me">Jiasi Shen</span><sup>1</sup>, Martin Rinard. </span><span class="date">2020. </span><span class="papertitle">An Empirical Study on the Impact of Deimplicitization on Comprehension in Programs Using Application Frameworks. </span><span class="booktitle">17th International Conference on Mining Software Repositories (<a class="venue" href="https://2020.msrconf.org/">MSR</a>), registered report. </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:msr20rr" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:msr20rr">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/msr20rr-deimplicit.pdf">Paper (pdf)</a>
<a class="btn btn-link btn-sm" href="https://doi.org/10.1145/3379597.3387507">DOI</a>
<a class="btn btn-link btn-sm" href="https://youtu.be/PqyiQhGQyyk">Talk</a></div>
<div class="abstract collapse" id="a:msr20rr"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">Background: Application frameworks, such as Ruby on Rails, introduce abstractions with the goal of simplifying development for particular application domains, such as web development.  While experts enjoy increased productivity due to these abstractions, the flow of the programs is often hard to understand for non-experts and newcomers due to implicit flow and concealed lower level action that seems like "magic".<br>Objective: We conjecture that converting these implicit flows into an explicit and unified form can help non-experts comprehend the programs using these frameworks.  We call the process of unifying distributed, implicit flows into a single routine <em>deimplicitization</em>.<br>Method: We want to conduct an experiment that studies the impact of deimplicitization on program comprehension.  Particularly, we want to study how software developers with different expertise (novices/students, framework experts/professional developers) can answer comprehension questions differently with respect to time and correctness, under the treatments of either a deimplicitized version of the program in Python or the original version of the program in Ruby on Rails.</p><a class="card-link" href="https://shenjiasi.com/assets/msr20rr-deimplicit.pdf">Paper (pdf)</a></div>
</div>
</li>
<li class="paper-tight" id="p:onward19"><span class="author">José Cambronero, Thurston Dang, Nikos Vasilakis, <span class="me">Jiasi Shen</span>, Jerry Wu, Martin Rinard. </span><span class="date">2019. </span><span class="papertitle">Active Learning for Software Engineering. </span><span class="booktitle">Proceedings of the 2019 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (<a class="venue" href="https://2019.splashcon.org/track/splash-2019-Onward-papers">Onward!</a>). </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:onward19" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:onward19">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/onward19-module.pdf">Paper (pdf)</a>
<a class="btn btn-link btn-sm" href="https://doi.org/10.1145/3359591.3359732">DOI</a></div>
<div class="abstract collapse" id="a:onward19"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">Software applications have grown increasingly complex to deliver the features desired by users. Software modularity has been used as a way to mitigate the costs of developing such complex software. Active learning-based program inference provides an elegant framework that exploits this modularity to tackle development correctness, performance and cost in large applications. Inferred programs can be used for many purposes, including generation of secure code, code re-use through automatic encapsulation, adaptation to new platforms or languages, and optimization. We show through detailed examples how our approach can infer three modules in a representative application. Finally, we outline the broader paradigm and open research questions.</p><a class="card-link" href="https://shenjiasi.com/assets/onward19-module.pdf">Paper (pdf)</a></div>
</div>
</li>
<li class="paper-tight" id="p:vlhcc19"><span class="author">José Cambronero<sup>1</sup>, <span class="me">Jiasi Shen</span><sup>1</sup>, Jürgen Cito<sup>1</sup>, Elena Glassman, Martin Rinard. </span><span class="date">2019. </span><span class="papertitle">Characterizing Developer Use of Automatically Generated Patches. </span><span class="booktitle">IEEE Symposium on Visual Languages and Human-Centric Computing (<a class="venue" href="https://human-se.github.io/vlhcc2019/">VL/HCC</a>), short paper. </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:vlhcc19" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:vlhcc19">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/vlhcc19-patches.pdf">Paper (pdf)</a>
<a class="btn btn-link btn-sm" href="https://doi.org/10.1109/VLHCC.2019.8818884">DOI</a></div>
<div class="abstract collapse" id="a:vlhcc19"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">We present a study that characterizes the way developers use automatically generated patches when fixing software defects. Our study tasked two groups of developers with repairing defects in C programs. Both groups were provided with the defective line of code. One was also provided with five automatically generated and validated patches, all of which modified the defective line of code, and one of which was correct. Contrary to our initial expectations, the group with access to the generated patches did not produce more correct patches and did not produce patches in less time. We characterize the main behaviors observed in experimental subjects: a focus on understanding the defect and the relationship of the patches to the original source code. Based on this characterization, we highlight various potentially productive directions for future developer-centric automatic patch generation systems.</p><a class="card-link" href="https://shenjiasi.com/assets/vlhcc19-patches.pdf">Paper (pdf)</a></div>
</div>
</li>
<li class="paper-tight" id="p:pldi19"><span class="author"><span class="me">Jiasi Shen</span>, Martin Rinard. </span><span class="date">2019. </span><span class="papertitle">Using Active Learning to Synthesize Models of Applications that Access Databases. </span><span class="booktitle">Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (<a class="venue" href="https://conf.researchr.org/home/pldi-2019">PLDI</a>). </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:pldi19" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:pldi19">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/pldi19-konure.pdf">Paper (pdf)</a>
<a class="btn btn-link btn-sm" href="https://doi.org/10.1145/3314221.3314591">DOI</a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/pldi2019.code/">Code</a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/pldi19-konure-slides.pptx">Slides (pptx)</a>
<a class="btn btn-link btn-sm" href="https://youtu.be/2WVgTwyKT_M">Talk</a></div>
<div class="abstract collapse" id="a:pldi19"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">We present <em>Konure</em>, a new system that uses active learning to infer models of applications that access relational databases. Konure comprises a domain-specific language (each model is a program in this language) and associated inference algorithm that infers models of applications whose behavior can be expressed in this language. The inference algorithm generates inputs and database configurations, runs the application, then observes the resulting database traffic and outputs to progressively refine its current model hypothesis. Because the technique works with only externally observable inputs, outputs, and database configurations, it can infer the behavior of applications written in arbitrary languages using arbitrary coding styles (as long as the behavior of the application is expressible in the domain-specific language). Konure also implements a regenerator that produces a translated Python implementation of the application that systematically includes relevant security and error checks.</p><a class="card-link" href="https://shenjiasi.com/assets/pldi19-konure.pdf">Paper (pdf)</a></div>
</div>
</li>
<li class="paper-tight" id="p:onward18"><span class="author">Martin Rinard, <span class="me">Jiasi Shen</span>, Varun Mangalick. </span><span class="date">2018. </span><span class="papertitle">Active Learning for Inference and Regeneration of Computer Programs that Store and Retrieve Data. </span><span class="booktitle">Proceedings of the 2018 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (<a class="venue" href="https://2018.onward-conference.org/track/onward-2018-papers">Onward!</a>). </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:onward18" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:onward18">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/onward18-blackbox.pdf">Paper (pdf)</a>
<a class="btn btn-link btn-sm" href="https://doi.org/10.1145/3276954.3276959">DOI</a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/onward18-blackbox-slides.pptx">Slides (pptx)</a></div>
<div class="abstract collapse" id="a:onward18"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">As modern computation platforms become increasingly complex, their programming interfaces are increasingly difficult to use. This complexity is especially inappropriate given the relatively simple core functionality that many of the computations implement. We present a new approach for obtaining software that executes on modern computing platforms with complex programming interfaces. Our approach starts with a simple seed program, written in the language of the developer's choice, that implements the desired core functionality. It then systematically generates inputs and observes the resulting outputs to learn the core functionality. It finally automatically regenerates new code that implements the learned core functionality on the target computing platform. This regenerated code contains boilerplate code for the complex programming interfaces that the target computing platform presents. By providing a productive new mechanism for capturing and encapsulating knowledge about how to use modern complex interfaces, this new approach promises to greatly reduce the developer effort required to obtain secure, robust software that executes on modern computing platforms.</p><a class="card-link" href="https://shenjiasi.com/assets/onward18-blackbox.pdf">Paper (pdf)</a></div>
</div>
</li>
<li class="paper-tight" id="p:sle17"><span class="author"><span class="me">Jiasi Shen</span>, Martin Rinard. </span><span class="date">2017. </span><span class="papertitle">Robust Programs with Filtered Iterators. </span><span class="booktitle">Proceedings of 2017 ACM SIGPLAN International Conference on Software Language Engineering (<a class="venue" href="http://www.sleconf.org/2017/">SLE</a>). </span><span class="award">Distinguished Artifact Award. </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:sle17" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:sle17">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/sle17-rifl.pdf">Paper (pdf)</a>
<a class="btn btn-link btn-sm" href="https://doi.org/10.1145/3136014.3136030">DOI</a>
<a class="btn btn-link btn-sm" href="http://people.csail.mit.edu/jiasi/sle2017_rifl_artifact/">Artifact</a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/sle17-rifl-slides.pptx">Slides (pptx)</a>
<a class="btn btn-link btn-sm" href="https://youtu.be/RiJm5rZuFIQ">Talk</a></div>
<div class="abstract collapse" id="a:sle17"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">We present a new language construct, <em>filtered iterators</em>, for robust input processing. Filtered iterators are designed to eliminate many common input processing errors while enabling robust continued execution. The design is inspired by (1) observed common input processing errors and (2) successful strategies implemented by human developers fixing input processing errors. Filtered iterators decompose inputs into input units and atomically and automatically discard units that trigger errors. Statistically significant results from a developer study demonstrate the effectiveness of filtered iterators in enabling developers to produce robust input processing code without common input processing defects.</p><a class="card-link" href="https://shenjiasi.com/assets/sle17-rifl.pdf">Paper (pdf)</a></div>
</div>
</li>
<li class="paper-tight" id="p:mmsp15"><span class="author">Jun Sun, Yizhou Duan, Qi Zhang, <span class="me">Jiasi Shen</span>, Zongming Guo. </span><span class="date">2015. </span><span class="papertitle">Towards Rate-Distortion Analysis of General Source Distributions: Property and Principles. </span><span class="booktitle">IEEE 17th International Workshop on Multimedia Signal Processing (MMSP). </span></li></ul>
</span>

      <p> (1: Equal contribution.) </p>
      <h3>Patents</h3>
      
<span class="paper-list">
<ul><li class="paper-tight" id="p:uspto22"><span class="author"><span class="me">Jiasi Shen</span>, Homer Strong, Daniel George Peebles, Neha Rungta. </span><span class="date">2022. </span><span class="papertitle">Generating Access Management Policies from Example Requests. </span><span class="booktitle">United States Patent (Patent No.: US 11,483,353 B1). </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:uspto22" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:uspto22">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/uspto22-policies.pdf">Paper (pdf)</a></div>
<div class="abstract collapse" id="a:uspto22"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">Access management policies may be generated from example requests. An access management policy may be received. One or more example requests that have expected results when evaluated with respect to the access management policy may be received. Updates to the access management policy may be determined that cause the expected results to occur when a new version of the access management policy based on the updates is enforced. The new version of the access management policy may be generated based on the updates.</p><a class="card-link" href="https://shenjiasi.com/assets/uspto22-policies.pdf">Paper (pdf)</a></div>
</div>
</li></ul>
</span>

      <h3>Theses</h3>
      
<span class="paper-list">
<ul><li class="paper-tight" id="p:thesis22"><span class="author"><span class="me">Jiasi Shen</span>. </span><span class="date">2022. </span><span class="papertitle">Program Inference and Regeneration via Active Learning. </span><span class="booktitle">Ph.D. Thesis, Massachusetts Institute of Technology. </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:thesis22" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:thesis22">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/assets/thesis22.pdf">Paper (pdf)</a>
<a class="btn btn-link btn-sm" href="https://hdl.handle.net/1721.1/147330">DOI</a>
<a class="btn btn-link btn-sm" href="https://shenjiasi.com/thesis2022.code/">Benchmarks</a></div>
<div class="abstract collapse" id="a:thesis22"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">Software now plays a central role in numerous aspects of human society. Current software development practices involve significant developer effort in all phases of the software life cycle, including the development of new software, detection and elimination of defects and security vulnerabilities in existing software, maintenance of legacy software, and integration of existing software into more contexts, with the quality of the resulting software still leaving much to be desired. The goal of my research is to improve software quality and reduce costs by automating tasks that currently require substantial manual engineering effort.<br> I present a novel approach for program inference and regeneration, which takes an existing program, learns its core functionality as a black box, builds a model that captures this functionality, and uses the model to generate a new program.  The new program delivers the same core functionality but is potentially augmented or transformed to eliminate defects, systematically introduce safety or security checks, or operate successfully in different environments. <br> This research enables the rejuvenation and retargeting of existing software and provides a powerful way for developers to express program functionality that adapts flexibly to a variety of contexts.  For instance, one benefit is enabling new development methodologies that work with simple prototype implementations as specifications, then use regeneration to automatically obtain clean, efficient, and secure implementations.  Another benefit is automatically improving program comprehension and producing cleaner code, making the code more transparent and the developers more productive.  A third benefit is automatically extracting the human knowledge crystallized and encapsulated in legacy software systems and retargeting it to new languages and platforms, including languages and platforms that provide more powerful features. <br> In this thesis, I present two systems that implement this approach for database-backed programs.</p><a class="card-link" href="https://shenjiasi.com/assets/thesis22.pdf">Paper (pdf)</a></div>
</div>
</li>
<li class="paper-tight" id="p:thesis15"><span class="author"><span class="me">Jiasi Shen</span>. </span><span class="date">2015. </span><span class="papertitle">RIFL: A Language with Filtered Iterators. </span><span class="booktitle">Master's Thesis, Massachusetts Institute of Technology. </span><div class="links"><a class="btn btn-link btn-sm" href="https://shenjiasi.com/papers.html#a:thesis15" data-toggle="collapse" role="button" aria-expanded="false" aria-controls="a:thesis15">Abstract<svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></a>
<a class="btn btn-link btn-sm" href="http://hdl.handle.net/1721.1/101587">DOI</a></div>
<div class="abstract collapse" id="a:thesis15"><div class="card bg-light card-body p-2 mb-2"><p class="card-text">RIFL is a new programming language that enables developers to write only common-case code to robustly process structured inputs. RIFL eliminates the need to manually handle errors with a new control structure, filtered iterators. A filtered iterator treats inputs as collections of input units, iterates over the units, uses the program itself to filter out unanticipated units, and atomically updates program state for each unit. Filtered iterators can greatly simplify the development of robust programs. We formally define filtered iterators in RIFL. The semantics of filtered iterators ensure that each input unit affects program execution atomically. Our benchmarks show that using filtered iterators reduces an average of 41.7% lines of code, or 58.5% conditional clauses and 33.4% unconditional computation, from fully manual implementations.</p></div>
</div>
</li></ul>
</span>

      <br>
    </div>
    
<footer class="pt-5">
  <div class="small text-muted border-top px-4 py-2">
    © 2019 Jiasi Shen.
    Last updated Feb 18, 2024.<br>
  </div>
</footer>

  
</body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>